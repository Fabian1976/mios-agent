#!/usr/bin/python
#
# Explenation fields /proc/diskstats
#  Field  1 -- # of reads completed
#      This is the total number of reads completed successfully.
#  Field  2 -- # of reads merged, field 6 -- # of writes merged
#      Reads and writes which are adjacent to each other may be merged for
#      efficiency.  Thus two 4K reads may become one 8K read before it is
#      ultimately handed to the disk, and so it will be counted (and queued)
#      as only one I/O.  This field lets you know how often this was done.
#  Field  3 -- # of sectors read
#      This is the total number of sectors read successfully.
#  Field  4 -- # of milliseconds spent reading
#      This is the total number of milliseconds spent by all reads (as
#      measured from __make_request() to end_that_request_last()).
#  Field  5 -- # of writes completed
#      This is the total number of writes completed successfully.
#  Field  7 -- # of sectors written
#      This is the total number of sectors written successfully.
#  Field  8 -- # of milliseconds spent writing
#      This is the total number of milliseconds spent by all writes (as
#      measured from __make_request() to end_that_request_last()).
#  Field  9 -- # of I/Os currently in progress
#      The only field that should go to zero. Incremented as requests are
#      given to appropriate struct request_queue and decremented as they finish.
#  Field 10 -- # of milliseconds spent doing I/Os
#      This field is increases so long as field 9 is nonzero.
#  Field 11 -- weighted # of milliseconds spent doing I/Os
#      This field is incremented at each I/O start, I/O completion, I/O
#      merge, or read of these stats by the number of I/Os in progress
#      (field 9) times the number of milliseconds spent doing I/O since the
#      last update of this field.  This can provide an easy measure of both
#      I/O completion time and the backlog that may be accumulating.

__author__    = "Jan van de Beek, Fabian van der Hoeven"
__copyright__ = "Copyright (C) 2013 Vermont 24x7"
__version__   = "3.2"

import sys, os, time, getopt
from threading import *
from socket import *
from struct import *
import struct
import re
import ConfigParser
import platform
import getopt
import logging, logging.handlers

oracle = None
probes = None
config = None
disk_stat = None
postgres = None

class Config:

	def __init__(self, ini_file):

		self.config          = None
		self.ini_file        = ''
		self.output          = ''
		self.listen_ip       = ''
		self.listen_port     = 0
		self.logfile         = ''
		self.loglevel        = ''
		self.hostname        = ''
		self.zabbix_agent    = ''
		self.zabbix_port     = 0
		self.oracle_sids     = {}
		self.oracle_oa_dir   = ''
		self.postgres_dbs    = {}
		try:
			self.pagent_home = os.environ['PAGENT_HOME']
		except:
			self.pagent_home = "/home/mios/pagent"

		self.ini_file = ini_file
		if not os.path.exists(self.ini_file):
			print "Can't open config file %s" % self.ini_file

		self.config = ConfigParser.ConfigParser()
		self.config.read(self.ini_file)

	def parse(self):

		try:
			self.output         = self.config.get('common', 'output')
			self.output         = [strip(x) for x in self.output]
		except:
			pass

		try:
			self.listen_ip      = self.config.get('common', 'listen_ip')
		except:
			self.listen_ip      = 'localhost'

		try:
			self.listen_port    = int(self.config.get('common', 'listen_port'))
		except:
			self.listen_port    = 10050

		try:
			self.logfile        = self.config.get('common', 'logfile')
		except:
			self.logfile        = self.pagent_home + '/log/pagent.log'

		try:
			self.loglevel       = self.config.get('common', 'loglevel')
		except:
			self.loglevel       = 'INFO'

		try:
			self.hostname       = self.config.get('common', 'hostname')
		except:
			self.hostname       = platform.node()

		try:
			self.zabbix_agent   = self.config.get('common', 'zabbix_agent')
		except:
			self.zabbix_agent   = 'localhost'

		try:
			self.zabbix_port    = self.config.getint('common', 'zabbix_port')
		except:
			self.zabbix_port    = 10051

		print "[common]"
		print "INI file             : %s" % self.ini_file
		print "Output               :", self.output
		print "Listen on ip address : %s" % self.listen_ip
		print "Listen on port       : %d" % self.listen_port
		print "Log file             : %s" % self.logfile
		print "Hostname             : %s" % self.hostname
		print "Zabbix agent ip      : %s" % self.zabbix_agent
		print "Zabbix agent port    : %s" % self.zabbix_port

		sections = self.config.sections()
		for section in sections:
			if section == 'common':
				continue
			dbtype = section.split('.')[0]
			if dbtype == 'oracle':
				sid                     = section.split('.')[1]
				user                    = self.config.get(section, 'user')
				password                = self.config.get(section, 'password')
				self.oracle_sids[sid]   = (user, password)
				self.oracle_oa_dir      = self.config.get(section, 'oa_dir')
				global OA_DIR
				OA_DIR                  = self.oracle_oa_dir
				print ""
				print section
				print "Oracle SID		: %s" % sid
				print "Oracle user		: %s" % user
				print "Oracle password		: %s" % password
				print "Oracle OA_DIR		: %s" % self.oracle_oa_dir
			if dbtype == 'postgres':
				dbname			= section.split('.')[1]
				host			= self.config.get(section, 'host')
				port			= self.config.get(section, 'port')
				user			= self.config.get(section, 'user')
				password		= self.config.get(section, 'password')
				self.postgres_dbs[dbname] = (host, port, user, password)
				print ""
				print section
				print "Postgres DB		: %s" % dbname
				print "Postgres host		: %s" % host
				print "Postgres port		: %s" % port
				print "Postgres user		: %s" % user
				print "Postgres password	: %s" % password
			if dbtype not in ('oracle', 'postgres'):
				print "Unsupported database type: %s" % dbtype

class Probes:

	def __init__(self):

		self.probe_list = {}

		logging.info("Caching probes...")
		for file in os.listdir(config.pagent_home + '/probes'):
			f = open(config.pagent_home + '/probes/' + file)
			type = f.readline()
			try:
				type = type.split('=')[1].strip()
			except:
				logging.error("Found probes with no type definition on the first line: %s" % file)
				type = 'unknown'
			action = f.read()
			logging.debug("Probe cached - type: %s, action: %s" % (type, action))
			self.probe_list[file] = [type, action]
			f.close()

	def get_action(self, probe):

		try:
			return self.probe_list[probe][1]
		except KeyError:
			logging.info("Probe not found in cache. Trying to load new probe: %s" % probe)
			if os.path.exists(config.pagent_home + '/probes/' + probe):
				f = open(config.pagent_home + '/probes/' + probe)
				type = f.readline()
				try:
					type = type.split('=')[1].strip()
				except:
					logging.error("Found probes with no type definition on the first line: %s" % probe)
					type = 'unknown'
				action = f.read()
				self.probe_list[probe] = [type, action]
				f.close()
				return self.probe_list[probe][1]
			else:
				logging.error("No probe file: %s" % probe)
				return -1

class Oracle(object):

	def __init__(self, instances):

		self.oracle_support  = 0
		self.connections     = []
		self.cursor          = []
		self.version         = []
		self.user            = []
		self.password        = []
		self.sids            = []
		self.instances       = instances
		self.last_connect    = []

		try:
			import cx_Oracle
			self.cx_Oracle = cx_Oracle
			self.oracle_support = 1
			logging.info("Sucessfully loaded cx_Oracle module")
		except ImportError:
			logging.critical("Module cx_Oracle is not installed, please install it!")
			raise
		except:
			logging.critical("Error while loading Module cx_Oracle!")
			raise

		if self.oracle_support == 0:
			return None

		for instance in instances:
			user, password = instances[instance]

			sql_file = OA_DIR + "/" + instance + "/sql/mios.sql"
			if os.path.exists(sql_file):
				sql = open(sql_file, "r")
				line = sql.read()
				m = re.search('^\s*connect\s+(\w+)\/(\S+)\s', line)
				if m:
					self.user.append(m.group(1))
					self.password.append(m.group(2))
				else:
					logging.error("instance %s has no file %s" % (instance, sql_file))
				sql.close()
			elif user == '' or password == '':
				logging.error("File: %s doesn't exist" % sql_file)
				sys.exit(1)

			self.user.append(user)
			self.password.append(password)
			self.sids.append(instance)
			self.connections.append(None)
			self.cursor.append(None)
			self.version.append('')
			indx = self.sids.index(instance)
			self.last_connect.append(0)
			self.connect(indx)

	def connect(self, indx):

		while self.connections[indx] == None:
			try:
				self.connections[indx]  = self.cx_Oracle.connect("%s/%s@%s" % (self.user[indx], self.password[indx], self.sids[indx]))
				logging.info("Connection succesful")
				time.sleep(2)
			except Exception, e:
				logging.critical("Unable to connect to Oracle")
				logging.critical("ORA: Additional information: %s" % e)
				logging.info("Trying to reconnect in 10 seconds")
				time.sleep(10)
		self.cursor[indx]       = self.connections[indx].cursor()
		self.version[indx]      = self.connections[indx].version
		self.last_connect[indx] = time.time()
		logging.info("Connect to Oracle version %s SID: %s" % (self.version[indx], self.sids[indx]))

	def reconnect(self, data):

		if  data.find('[') > 0:
			(item, arguments) = data.split('[')
			arguments = arguments.replace(']','')
		else:
			logging.error("no oracle sid specified")
			return None
		arguments = arguments.replace(' ','')
		arguments = arguments.rstrip()
		sid = ''
		if  data.find(',') > 0:
			fields = arguments.split(',')
			sid = fields[0]
		else:
			sid = arguments

		if not sid in self.sids:
			logging.error("Unknown SID: %s" % sid)
			logging.error("Additional info: %s" % data)
			return

		indx = self.sids.index(sid)
		logging.debug("indx: %s" % indx)

		try:
			self.connections[indx] = self.cx_Oracle.connect("%s/%s@%s" % (self.user[indx], self.password[indx], self.sids[indx]))
		except Exception, e:
			logging.critical("Unable to connect to Oracle")
			logging.critical("ORA: Additional information: %s" % e)
		self.cursor[indx]      = self.connections[indx].cursor()
		self.version[indx]    = self.connections[indx].version
		logging.info("Connect to Oracle version %s SID: %s" % (self.version[indx], self.sids[indx]))
		self.last_connect[indx] = time.time()

	def get(self, data):

		fields=[]

		if self.oracle_support == 0:
			logging.error("Oracle not supported")
			return None

		if  data.find('[') > 0:
			(item, arguments) = data.split('[')
			arguments = arguments.replace(']','')
		else:
			logging.error("no oracle sid specified")
			return None
		arguments = arguments.replace(' ','')
		arguments = arguments.rstrip()
		sid = ''
		if  data.find(',') > 0:
			fields = arguments.split(',')
			sid = fields[0]
		else:
			sid = arguments
		top_item = item.split('.')
		action=probes.get_action(item)
		m = re.search('MIOS_ARG_2', action)
		if m:
			action = re.sub('MIOS_ARG_2', fields[1], action)

		if not sid in self.sids:
			logging.error("SID not found in list of SIDS from config file")
			return -1

		try:
			indx = self.sids.index(sid)
			try:
				self.cursor[indx].execute(action)
			except Exception, e:
				logging.error("ORA: Failed to execute query: %s" % action)
				logging.error("ORA: Additional info: %s" % e)
				ORA_error = e.split(':')[0]
				if ORA_error == 'ORA-03113': #Not connected to Oracle
					return -2 #Forces parent to reconnect
				else:
					return -1

			try:
				value = self.cursor[indx].fetchone()[0]
			except Exception, e:
				logging.error("ORA: Failed to fetch result from resultset")
				logging.error("ORA: Additional info: %s" % e)
				return -1

			logging.debug("indx: %d sid: %s action: %s value: %s" % (indx, sid, action.rstrip("\n\r"), str(value)))
			return value
		except:
			logging.error("Error in Oracle connection SID: %s" % sid)
			return -2

	def execute(self, sid, query):

		if self.oracle_support == 0:
			logging.error("Oracle not supported")
			return None

		if not sid in self.sids:
			return -1
		try:
			indx = self.sids.index(sid)
			try:
				self.cursor[indx].execute(query)
			except Exception, e:
				logging.error("ORA: Failed to execute query: %s" % action)
				logging.error("ORA: Additional info: %s" % e)
				return -1

			try:
				value = self.cursor[indx].fetchall()
			except Exception, e:
				logging.error("ORA: Failed to fetch resultset")
				logging.error("ORA: Additional info: %s" % e)
				return -1

			logging.debug("indx: %d sid: %s action: %s value: %s" % (indx, sid, query, str(value)))
			return value
		except:
			logging.error("Error in Oracle connection SID: %s" % sid)
			return -2

class Postgres(object):

	def __init__(self, instances):

		self.postgres_support = 0
		self.connections      = []
		self.cursor           = []
		self.version          = []
		self.host             = []
		self.port             = []
		self.user             = []
		self.password         = []
		self.dbs              = []
		self.instances        = instances
		self.last_connect     = []

		try:
			import psycopg2
			self.psycopg2 = psycopg2
			self.postgres_support = 1
			logging.info("Successfully loaded psycopg2 module")
		except ImportError:
			logging.error("Module psycopg2 is not installed, please install it!")
			raise
		except:
			logging.error("Error while loading psycopg2 module!")
			raise

		if self.postgres_support == 0:
			return None

		for instance in instances:
			host, port, user, password = instances[instance]
			self.host.append(host)
			self.port.append(port)
			self.user.append(user)
			self.password.append(password)
			self.dbs.append(instance)
			self.connections.append(None)
			self.cursor.append(None)
			self.version.append('')
			indx = self.dbs.index(instance)
			self.last_connect.append(0)
			self.connect(indx)

	def connect(self, indx):

		while self.connections[indx] == None:
			try:
				self.connections[indx] = self.psycopg2.connect("host='%s' port='%s' dbname='%s' user='%s' password='%s'" % (self.host[indx], self.port[indx], self.dbs[indx], self.user[indx], self.password[indx]))
				logging.info("Connection succesful")
				time.sleep(2)
			except Exception, e:
				logging.critical("Unable to connect to Postgres")
				logging.critical("PG: Additional information: %s" % e)
				logging.info("Trying to reconnect in 10 seconds")
				time.sleep(10)
		self.cursor[indx]      = self.connections[indx].cursor()
		self.cursor[indx].execute('select version()')
		self.version[indx]     = self.cursor[indx].fetchone()
		self.last_connect      = time.time()
		logging.info("Connect to Postgres version %s DB: %s" % (self.version[indx], self.dbs[indx]))

	def reconnect(self,data):

		if data.find('[') > 0:
			(item, arguments) = data.split('[')
			arguments = arguments.replace(']','')
		else:
			logging.error("no postgres db specified")
			return None
		arguments = arguments.replace(' ','')
		arguments = arguments.rstrip()
		db = ''
		if data.find(',') > 0:
			fields = arguments.split(',')
			db = fields[0]
		else:
			db = arguments

		if not db in self.dbs:
			return

		indx = self.dbs.index(db)
		print "indx", indx

		self.connections[indx] = self.psycopg2.connect("host='%s' port='%s' dbname='%s' user='%s' password='%s'" % (self.host[indx], self.port[indx], self.dbs[indx], self.user[indx], self.password[indx]))
		self.cursor[indx]      = self.connections[indx].cursor()
		self.cursor[indx].execute('select version()')
		self.version[indx]     = self.cursor[indx].fetchone()
		self.last_connect      = time.time()
		logging.info("Connect to Postgres version %s DB: %s" % (self.version[indx], self.dbs[indx]))

	def get(self, data):

		fields = []

		if self.postgres_support == 0:
			logging.error("Postgres not supported")
			return None

		if  data.find('[') > 0:
			(item, arguments) = data.split('[')
			arguments = arguments.replace(']','')
		else:
			logging.error("no postgres db specified")
			return None
		arguments = arguments.replace(' ','')
		arguments = arguments.rstrip()
		db = ''
		if  data.find(',') > 0:
			fields = arguments.split(',')
			db = fields[0]
		else:
			db = arguments
		top_item = item.split('.')
		action=probes.get_action(item)
		m = re.search('MIOS_ARG_2', action)
		if m:
			action = re.sub('MIOS_ARG_2', fields[1], action)

		if not db in self.dbs:
			logging.error("DB not found in list of DBS from config file")
			return -1

		try:
			indx = self.dbs.index(db)
			try:
				self.cursor[indx].execute(action)
			except Exception, e:
				logging.error("PG: Failed to execute query: %s" % action)
				logging.error("PG: Additional info: %s" % e)
				return -1

			try:
				value = self.cursor[indx].fetchone()[0]
			except Exception, e:
				logging.error("PG: Failed to fetch result from resultset")
				logging.error("PG: Additional info: %s" % e)
				return -1

			logging.debug("indx: %d db: %s action: %s value: %s" % (indx, db, action.rstrip("\n\r"), str(value)))
			# Postgres has to have a commit after each select or else the table (pg_stat_database) will seem static
			# In future maybe filter query's to this table so that not every select has a commit
			self.connections[indx].commit()
			return value
		except:
			logging.error("Error in Postgres connection DB: %s" % db)
			return -2

class DiskStats(object):

	def __init__(self):

		self.device_name  = []
		self.major_minor  = []
		self.filesystems  = []
		self.fs_type      = []
		self.read_write   = []
		self.no_probes    = 0
		self.data         = []
		self.last_update  = 0
		self.stats        = []
		self.MIN_INTERVAL = 30

		self.get_fs_mapping()
		self.init_stats()
		self.update_stats();

	def init_stats(self):

		f = open('/proc/diskstats', 'r')
		for line in f:
			fields = line.split()
			try:
				a="%s-%s" % (fields[0],fields[1])
				i = self.major_minor.index(a)
				fs = self.filesystems[i]
				self.data[i] = fields
				now = time.time()
				self.last_update = now
				self.stats[i] = [0,0,0,0,0,0]
			except:
				pass
		f.close()
		self.last_update = time.time()
		self.no_probes+=1

	def get_fs_mapping(self):

		f = open('/etc/mtab', 'r')
		for line in f:
			fields = line.split()
			self.device_name.append(fields[0].replace("/dev/",""))
			if fields[2] == "ext3":
				stat  = os.stat(fields[0])
				inode = stat.st_rdev
				self.major_minor.append( "%d-%d" % ( os.major(inode), os.minor(inode)))
				logging.debug("%s-%s %s" % ( os.major(inode), os.minor(inode), fields[1] ))
				self.filesystems.append(fields[1])
				self.fs_type.append(fields[2])
				self.read_write.append(fields[3])
				self.data.append([0,0,0,0,0,0,0,0,0,0,0])
				self.stats.append([0,0,float(0.0),0,0,float(0.0)])
				now = time.time()
				self.last_update = now
		f.close()

	def list_fs(self):

		for fs in filesystems:
			print fd + "\n"

	def update_stats(self):

		f = open('/proc/diskstats', 'r')
		diff = 0
		if self.last_update > 0:
			diff = time.time() - self.last_update
		for line in f:
			fields = line.split()
			a="%s-%s" % (fields[0],fields[1])
			try:
				i = self.major_minor.index(a)
				try:
					self.stats[i] = [ ( int(fields[3]) - int(self.data[i][3]) ) / diff,
								( int(fields[5]) - int(self.data[i][5]) ) * 512 / diff,
								float( ( float(fields[6]) - float(self.data[i][6]) ) / ( float(fields[3]) - float(self.data[i][3]) ) ),
								( int(fields[7]) - int(self.data[i][7]) ) / diff,
								( int(fields[9]) - int(self.data[i][9]) ) * 512 / diff,
								float( ( float(fields[10]) - float(self.data[i][10]) ) / ( float(fields[7]) - float(self.data[i][7]) ) )
							]

				except:
					pass
				logging.debug("STATS: %d - %d - %d - %d" % ( self.stats[i][0], self.stats[i][1], self.stats[i][3], self.stats[i][4] ))
				self.data[i] = fields
			except:
				pass
		f.close()
		self.last_update = time.time()

	def get_attr(self, fs, nof):

		ret = 0
		now = time.time()
		if now - self.last_update > self.MIN_INTERVAL:
			self.update_stats()
		for line in self.filesystems:
			 i = self.filesystems.index(line)
			 _fs = self.filesystems[i]
			 if _fs == fs:
				ret = self.stats[i][nof]
		self.no_probes+=1
		return ret

class ConnectionHandler:

	def __init__(self, _conn):

		self.conn    = _conn
		self.counter = 1

	def start(self):

		mtype = "ZABBIX"
		data = self.conn.recv(1024)
		data_orig = data
		logging.info("received: %s" % data.rstrip("\n\r"))
		if len(data) >= 4 and data[0:4] == 'MIOS':
			self.process_mios_call(data[4:])
			self.conn.close()
			return

		# Handle probe update
		if len(data) >= 4 and data[0:5] == 'PROBE':
			self.update_probe(data[5:])
			self.conn.close()
			return

		data.replace(' ','')
		item      = ''
		arguments = ''
		if  data.find('[') > 0:
			(item, arguments) = data.split('[')
			arguments = arguments.replace(']','')
		else:
			item = data
			item = item.rstrip()
		arguments = arguments.replace(' ','')
		arguments = arguments.rstrip()
		fields = arguments.split(',')
		top_item = item.split('.')[0]

		if top_item == 'oracle':
			if item.split('.')[1] == 'tablespace_discover':
				logging.debug("DISCOVER TABLESPACES")
				sid = arguments
				rows = oracle.execute(sid, "select tablespace_name from dba_tablespaces where contents not in ('UNDO', 'TEMPORARY')")
				if rows == -1:
					value = "ZBX_NOTSUPPORTED"
				else:
					value = '{ "data":['
					for row in rows:
						logging.debug('Tablespace found: %s' % row)
						value += '{ "{#TBSNAME}":"%s" },' % row
					value += '] }'
			else:
				value = oracle.get(data)
				if value == -1:
					value = "ZBX_NOTSUPPORTED"
				elif value == -2:
					logging.info("ORA: Lost connection. Trying to reconnect" % value)
					while value == -2:
						logging.info("sleep 5 seconds...")
						time.sleep(5)
						oracle.reconnect(data)
						value = oracle.get(data)
						if value != -2:
							value = str(value)
				else:
					value = str(value)

			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			self.conn.send( pack("Q%ds" % len(value), len(value), value) )

		elif top_item == 'postgres':
			value = postgres.get(data)

			if value == -1:
				value = "ZBX_NOTSUPPORTED"
			elif value == -2:
				logging.info("PG: Lost connection. Trying to reconnect" % value)
				while value == -2:
					logging.info("sleep 5 seconds...")
					time.sleep(5)
					postgres.reconnect(data)
					value = postgres.get(data)
					if value != -2:
						value = str(value)
				pass
			else:
				value = str(value)

			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			self.conn.send( pack("Q%ds" % len(value), len(value), value) )

		elif item == 'agent.ping':
			sys.stdout.flush()
			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			self.conn.send( pack('QB', 1, 0x30 + 1 ))

		elif item == 'perf.io':
			args = { 'riops': 0, 'rbps': 1, 'rst': 2, 'wiops': 3, 'wbps': 4, 'wst': 5 }
			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			value = disk_stat.get_attr(fields[0], args[fields[1]] )
			logging.debug("Received io arg1: %s arg2: %s send back: %s length: %d" % (arg1, arg2, value, len(str(value))))

			if fields[1][0:3] == 'rst' or fields[1][0:3] == 'wst':
				value_s = str(value)
				self.conn.send( pack("Q%ds" % len(value_s), len(value_s), str(value) ) )

			else:
				value_s = str(int(value))
				self.conn.send( pack("Q%ds" % len(value_s), len(value_s), str(value) ) )

		elif item == 'io.wt':
			logging.debug("Received io.wt")
			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			self.conn.send( pack('QB', 1, 0x30 + self.counter )[0:9] )

		elif item.split('.')[0] == 'oracle':
			sub_item = item.split('.')[1]
			ret = oracle.get(sub_item)

		elif item.split('.')[0] == 'postgres':
			sub_item = item.split('.')[1]
			ret = postgres.get(sub_item)

		elif top_item == 'proc':

			action = 0
			file   = ''
			row    = 0
			col    = 0
			value  = 0

			if item not in ["proc.num", "proc.mem"]: #Ignore Zabbix own proc probes
				action = probes.get_action(item)
			else:
				logging.debug("Ignored: %s, directly sent to zabbix agent" % item)
				action = -1

			if action == -1:
				# Let's give the job to the Zabbix agent
				s = socket(AF_INET, SOCK_STREAM)
				try:
					s.connect((config.zabbix_agent, config.zabbix_port))
					logging.debug("PROC: Connection to Zabbix agent on %s:%s succesfull" % (config.zabbix_agent, config.zabbix_port))
				except:
					logging.error("PROC: Connection to Zabbix agent on %s:%s failed" % (config.zabbix_agent, config.zabbix_port))
				s.send(data_orig)
				header = s.recv(5, MSG_WAITALL)
				bsize = s.recv(8, MSG_WAITALL)
				size = 0
				size = struct.unpack("Q", bsize)[0]
				message = s.recv(size, MSG_WAITALL)
				self.conn.send(header)
				self.conn.send(bsize + message)
				s.close()
				self.conn.close()
				return

			try:
				file, row, col = action.split(' ')
				row = int(row)
				col = int(col)
			except:
				value = -1

			if value == -1:
				value = "ZBX_NOTSUPPORTED"

			else:
				try:
					p = open(file, "r")
					r = 0
					c = 0
					while r <= row:
						line = p.readline()
						if r == row:
							field = line.split()
							value = field[col]
						r += 1

					p.close()
				except Exception, e:
					logging.error("Exception during proc probe: %s" % e)
					value = "ZBX_NOTSUPPORTED"


			self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
			self.conn.send( pack("Q%ds" % len(value), len(value), value) )

		else:

			s = socket(AF_INET, SOCK_STREAM)
			try:
				s.connect((config.zabbix_agent, config.zabbix_port))
				logging.debug("ZBX: Connection to Zabbix agent on %s:%s succesfull" % (config.zabbix_agent, config.zabbix_port))
			except:
				logging.error("ZBX: Connection to Zabbix agent on %s:%s failed" % (config.zabbix_agent, config.zabbix_port))
			s.send(data_orig)
			header = s.recv(5, MSG_WAITALL)
			bsize = s.recv(8, MSG_WAITALL)
			size = 0
			size = struct.unpack("Q", bsize)[0]
			message = s.recv(size, MSG_WAITALL)
			self.conn.send(header)
			self.conn.send(bsize + message)
			s.close()

		self.conn.close()

	def send_data(self, data):
		self.conn.send( pack('4s B', 'ZBXD', 1 )[0:5] )
		self.conn.close()

	def process_mios_call(self, data):

		logging.info("Received MIOS call: %s" % data)
		type, key, value = data.split('\0')
		logging.debug("type: %s key: %s value: %s" % (type, key, str(value)))
		s = socket(AF_INET, SOCK_STREAM)
		try:
			s.connect((config.zabbix_agent, config.zabbix_port))
			logging.debug("MIOS_call: Connection to Zabbix agent on %s:%s succesfull" % (config.zabbix_agent, config.zabbix_port))
			ts = time.time()

			message = "{\n\t\"request\":\"agent data\",\n\t\"data\":[\n\t\t{\n" \
				"\t\t\t\"host\":\"%s\",\n" \
				"\t\t\t\"key\":\"%s\",\n" \
				"\t\t\t\"value\":\"%d\"\n" \
				"\t\t\t\"clock\":%d\n"\
				"}\n" \
				"],\n" \
				"\t\"clock\":%d}" \
				% (config.hostname, key, int(value), ts, ts)

			s.send(pack('4s B', 'ZBXD', 1 )[0:5] )
			msize = len(message)
			template = "Q%ds" % (msize)
			s.send(pack(template, msize, message))
			s.close()
		except:
			logging.error("MIOS_call: Connection to Zabbix agent on %s:%s failed" % (config.zabbix_agent, config.zabbix_port))
			pass

	def update_probe(self, data):

		action      = data[0]
		size_name   = int(data[1:10])
		pointer     = 10 + size_name
		name        = data[10:pointer]
		size_data   = data[pointer:pointer + 9]
		pointer     = pointer + 9
		content     = data[pointer:]

		f = open(config.pagent_home + "/probes/%s" % name, "w")
		f.write(content)
		f.close()

#		data = self.conn.recv(1024)

def usage():
	print "usage: %s -c <config file> (--loglevel=loglevel)" % (sys.argv[0])
	print "\n<config file> - Location and name of the config file"
	print "-l (--loglevel=) optional parameter. Defines loglevel (DEBUG, INFO, WARNING, ERROR, CRITICAL). Default = INFO"
	print "The loglevel may also be configured in the config file"

def main():

	global vp
	global config
	global probes
	global oracle
	global disk_stat
	global postgres
	
	config_file = ''

	try:
		pagent_home = os.environ['PAGENT_HOME']
	except:
		pagent_home = "/home/mios/pagent"

	try:
		optlist, args = getopt.getopt(sys.argv[1:], 'lc:', ['loglevel='])
	except:
		usage()
		sys.exit(-1)

	if not optlist:
		print "No options specified"
		usage()
		sys.exit(-1)

	for o, v in optlist:
		if o == "-c":
			config_file = v

	if not config_file:
		print "No config file specified"
		usage()
		sys.exit(-1)

	config  = Config(config_file)
	config.parse()
	loglevel = config.loglevel
	# Loglevel parameter trumps loglevel in config file so arguments have to be parsed again
	for o, v in optlist:
		if o in ('-l', '--loglevel'):
			loglevel = v

	numeric_loglevel = getattr(logging, loglevel.upper(), None)
	if not isinstance(numeric_loglevel, int):
		raise ValueError('Invalid log level: %s' % loglevel)
	logging.basicConfig(level=numeric_loglevel, filename=config.logfile, format='[%(asctime)s] %(levelname)7s - %(message)s', datefmt='%d/%m/%Y %H:%M:%S')
	logging.info('============================= Start pagent ======================================')

	if len(sys.argv) == 1:
		if os.fork(): sys.exit(0)
		os.umask(0)
		os.setsid()
		if os.fork(): sys.exit(0)
		sys.stdout.flush()
		sys.stderr.flush()
		stdin  = file('/dev/null', 'r')
		stdout = file(config.logfile, 'a+')
		stderr = file(config.logfile, 'a+', 0)
		os.dup2(stdin.fileno(), sys.stdin.fileno())
		os.dup2(stdout.fileno(), sys.stdout.fileno())
		os.dup2(stderr.fileno(), sys.stderr.fileno())

	disk_stat=DiskStats()
	probes = Probes()
	if not config.oracle_sids:
		logging.info('No Oracle database present in config file')
	else:
		oracle = Oracle(config.oracle_sids)

	if not config.postgres_dbs:
		logging.info('No Postgres database present in config file')
	else:
		postgres = Postgres(config.postgres_dbs)

	s = socket(AF_INET,SOCK_STREAM)
	s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
	s.bind((config.listen_ip, config.listen_port))
	s.listen(5)

	while True:
		try:
			con,addr = s.accept()
			ch = ConnectionHandler(con)
			ch.start()
		except:
			pass

if __name__ == "__main__":

	main()
